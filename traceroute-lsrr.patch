diff -Nur traceroute-1.4a12.orig/configure.in traceroute-1.4a12/configure.in
--- traceroute-1.4a12.orig/configure.in	Wed Aug 15 16:32:50 2001
+++ traceroute-1.4a12/configure.in	Wed Aug 15 16:49:08 2001
@@ -46,6 +46,7 @@
 linux*)
 	V_INCLS="$V_INCLS -Ilinux-include -DUSE_KERNEL_ROUTING_TABLE"
 	AC_DEFINE(BYTESWAP_IP_HDR)
+	AC_DEFINE(HAVE_RAW_OPTIONS)
 	;;
 
 osf3*)
diff -Nur traceroute-1.4a12.orig/traceroute.c traceroute-1.4a12/traceroute.c
--- traceroute-1.4a12.orig/traceroute.c	Wed Aug 15 17:19:52 2001
+++ traceroute-1.4a12/traceroute.c	Wed Aug 15 17:19:02 2001
@@ -207,6 +207,7 @@
 #include <sys/socket.h>
 #include <sys/time.h>
 
+#include <net/if.h>
 #include <netinet/in_systm.h>
 #include <netinet/in.h>
 #include <netinet/ip.h>
@@ -230,6 +231,11 @@
 #include <string.h>
 #include <unistd.h>
 
+#ifdef __linux__
+#include <linux/types.h>
+#include <linux/icmp.h>
+#endif
+
 #include "gnuc.h"
 #ifdef HAVE_OS_PROTO_H
 #include "os-proto.h"
@@ -254,9 +260,9 @@
 #define NGATEWAYS ((int)((MAX_IPOPTLEN - IPOPT_MINOFF - 1) / sizeof(u_int32_t)))
 
 #ifndef MAXHOSTNAMELEN
-#define MAXHOSTNAMELEN	64
+#define MAXHOSTNAMELEN	256
 #endif
-
+ 
 #define Fprintf (void)fprintf
 #define Printf (void)printf
 
@@ -300,7 +306,10 @@
 struct sockaddr wherefrom;	/* Who we are */
 int packlen;			/* total length of packet */
 int minpacket;			/* min ip packet size */
-int maxpacket = 32 * 1024;	/* max ip packet size */
+#if !defined(IP_MAXPACKET)
+#define	IP_MAXPACKET	64 * 1024
+#endif
+int maxpacket = IP_MAXPACKET;	/* max ip packet size */
 int pmtu;			/* Path MTU Discovery (RFC1191) */
 u_int pausemsecs;
 
@@ -351,6 +360,14 @@
 #ifndef HAVE_USLEEP
 int	usleep(u_int);
 #endif
+
+#ifdef linux
+struct sockaddr_in *to = (struct sockaddr_in *)&whereto;
+#endif
+#ifndef LAUGHTER
+u_short uh_sport;
+#endif
+
 #ifdef USE_KERNEL_ROUTING_TABLE
 struct ifaddrlist *search_routing_table(struct sockaddr_in *to, struct ifaddrlist *al, int n);
 #endif
@@ -364,10 +381,12 @@
 	register u_char *outp;
 	register u_int32_t *ap;
 	register struct sockaddr_in *from = (struct sockaddr_in *)&wherefrom;
+#ifndef	linux
 	register struct sockaddr_in *to = (struct sockaddr_in *)&whereto;
+#endif
 	register struct hostinfo *hi;
-	int on = 1;
 	register struct protoent *pe;
+	int on = 1;
 	register int ttl, probe, i;
 	register int seq = 0;
 	int tos = 0, settos = 0;
@@ -598,7 +617,32 @@
 		outip->ip_p = IPPROTO_UDP;
 
 		outudp = (struct udphdr *)outp;
+#ifdef LAUGHTER
 		outudp->uh_sport = htons(ident);
+#else
+		/* Avoid udp port conflicts! */
+		if (!useicmp) {
+			struct sockaddr_in s;
+			int alen = sizeof(s);
+			int lock_fd = socket(AF_INET, SOCK_DGRAM, 0);
+			if (lock_fd < 0) {
+				perror("socket");
+				exit(1);
+			}
+			memset(&s, 0, sizeof(s));
+			if (bind(lock_fd, (struct sockaddr*)&s, sizeof(s)) == -1) {
+				perror("bind");
+				exit(1);
+			}
+			if (getsockname(lock_fd, (struct sockaddr*)&s, &alen) == -1) {
+				perror("getsockname");
+				exit(1);
+			}
+			uh_sport = s.sin_port;
+			outudp->uh_sport = s.sin_port;
+			/* DO NOT CLOSE LOCK SOCKET */
+		}
+#endif
 		outudp->uh_ulen =
 		    htons((u_short)(packlen - (sizeof(*outip) + optlen)));
 		outdata = (struct outdata *)(outudp + 1);
@@ -703,6 +747,52 @@
 		(void)setsockopt(sndsock, SOL_SOCKET, SO_DONTROUTE, (char *)&on,
 		    sizeof(on));
 
+#ifndef LAUGHTER
+	do {
+		int alen;
+		int probe_fd = socket(AF_INET, SOCK_DGRAM, 0);
+		int sport;
+
+		if (probe_fd < 0) {
+			perror("socket");
+			exit(1);
+		}
+		if (device) {
+			struct ifreq ifr;
+			strncpy(ifr.ifr_name, device, IFNAMSIZ-1);
+			if (setsockopt(probe_fd, SOL_SOCKET, SO_BINDTODEVICE, &ifr, sizeof(ifr)) == -1) {
+				close(probe_fd);
+				break;
+			}
+		}
+		sport = to->sin_port;
+		to->sin_port = htons(1025);
+		if (connect(probe_fd, (struct sockaddr*)to, sizeof(*to)) == -1) {
+			perror("socket");
+			exit(1);
+		}
+		to->sin_port = sport;
+		alen = sizeof(*from);
+		if (getsockname(probe_fd, (struct sockaddr*)from, &alen) == -1) {
+			perror("getsockname");
+			exit(1);
+		}
+		close(probe_fd);
+		if (source == NULL)
+			goto selected;
+		hi = gethostinfo(source);
+		source = hi->name;
+		hi->name = NULL;
+		for (i = hi->n, ap = hi->addrs; i > 0; --i, ++ap) {
+			if (from->sin_addr.s_addr == *ap) {
+				freehostinfo(hi);
+				goto selected;
+			}
+		}
+		freehostinfo(hi);
+	} while (0);
+#endif
+
 	/* Get the interface address list */
 	n = ifaddrlist(&allist, errbuf);
 	al = allist;
@@ -782,6 +872,9 @@
 #endif
 	}
 
+#ifndef LAUGHTER
+selected:
+#endif
 	/* Revert to non-privileged user after opening sockets */
 	setgid(getgid());
 	setuid(getuid());
@@ -795,6 +888,27 @@
 	}
 #endif
 
+#ifdef linux
+	if (bind(sndsock, (struct sockaddr *)from, sizeof(*from)) < 0) {
+		Fprintf(stderr, "%s: bind: %s\n",
+		    prog, strerror(errno));
+		exit (1);
+	}
+	if (bind(s, (struct sockaddr *)from, sizeof(*from)) < 0) {
+		Fprintf(stderr, "%s: bind ICMP socket: %s\n",
+			prog, strerror(errno));
+		exit (1);
+	}
+	if (1) {
+		struct icmp_filter filt;
+		filt.data = ~((1<<ICMP_TIMXCEED)|(1<<ICMP_UNREACH));
+		if (useicmp)
+			filt.data &= ~(1<<ICMP_ECHOREPLY);
+		if (setsockopt(s, SOL_RAW, ICMP_FILTER, (char*)&filt, sizeof(filt)) == -1)
+			perror("WARNING: setsockopt(ICMP_FILTER)");
+	}
+#endif
+
 	Fprintf(stderr, "%s to %s (%s)",
 	    prog, hostname, inet_ntoa(to->sin_addr));
 	if (source)
@@ -950,10 +1064,21 @@
 	struct ip tip;
 
 	outip->ip_ttl = ttl;
+#ifdef linux
+	/* Do not fiddle with ID, it must be unique
+	   and only kernel is allowed to make it. --ANK
+	*/
+	outip->ip_id = 0;
+#else
 #ifndef __hpux
 	outip->ip_id = htons(ident + seq);
 #endif
+#endif
 
+#ifdef LAUGHTER
+	/* The comment below has nothing to do with reality and
+	   udp cksum has nothing to do with ip one. --ANK
+	 */
 	/*
 	 * In most cases, the kernel will recalculate the ip checksum.
 	 * But we must do it anyway so that the udp checksum comes out
@@ -965,6 +1090,7 @@
 		if (outip->ip_sum == 0)
 			outip->ip_sum = 0xffff;
 	}
+#endif
 
 	/* Payload */
 	outdata->seq = seq;
@@ -984,6 +1110,7 @@
 		if (outicmp->icmp_cksum == 0)
 			outicmp->icmp_cksum = 0xffff;
 	} else if (doipcksum) {
+#ifdef FULL_CRAP_I_WONDER_WHY_LBNL_FOLKS_DID_IT
 		/* Checksum (we must save and restore ip header) */
 		tip = *outip;
 		ui = (struct udpiphdr *)outip;
@@ -999,6 +1126,29 @@
 		if (outudp->uh_sum == 0)
 			outudp->uh_sum = 0xffff;
 		*outip = tip;
+#else
+			struct udpmagichdr {
+				struct in_addr src;
+				struct in_addr dst;
+				u_char zero;
+				u_char proto;
+				u_short len;
+			} h, saved, *hptr;
+
+			h.src = outip->ip_src;
+			h.dst = to->sin_addr;
+			h.zero = 0;
+			h.proto = IPPROTO_UDP;
+			h.len = outudp->uh_ulen;
+			hptr = ((struct udpmagichdr*)outudp) - 1;
+			saved = *hptr;
+			*hptr = h;
+			outudp->uh_sum = 0;
+			outudp->uh_sum = in_cksum((u_short *)hptr, ntohs(outudp->uh_ulen) + sizeof(*hptr));
+			if (outudp->uh_sum == 0)
+				outudp->uh_sum = 0xffff;
+			*hptr = saved;
+#endif
 	}
 
 	/* XXX undocumented debugging hack */
@@ -1104,6 +1254,10 @@
 #else
 	icp = (struct icmp *)buf;
 #endif
+
+	if (in_cksum((u_short *)icp, htons(ip->ip_len) - hlen))
+		fprintf(stderr, "Icmp checksum is wrong\n");
+
 	type = icp->icmp_type;
 	code = icp->icmp_code;
 	/* Path MTU Discovery (RFC1191) */
@@ -1143,7 +1297,11 @@
 			/* XXX 8 is a magic number */
 			if (hlen + 12 <= cc &&
 			    hip->ip_p == IPPROTO_UDP &&
+#ifdef LAUGHTER
 			    up->uh_sport == htons(ident) &&
+#else
+			    up->uh_sport == uh_sport &&
+#endif
 			    up->uh_dport == htons(port + seq))
 				return (type == ICMP_TIMXCEED ? -1 : code + 1);
 		}
@@ -1186,6 +1344,8 @@
 
 /*
  * Checksum routine for Internet Protocol family headers (C Version)
+ *
+ * Certainly, it was broken --ANK
  */
 u_short
 in_cksum(register u_short *addr, register int len)
@@ -1208,7 +1368,7 @@
 
 	/* mop up an odd byte, if necessary */
 	if (nleft == 1)
-		sum += *(u_char *)w;
+		sum += htons(*(u_char *)w<<8);
 
 	/*
 	 * add back carry outs from top 16 bits to low 16 bits
